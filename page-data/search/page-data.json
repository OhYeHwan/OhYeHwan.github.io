{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"의미 있는 이름 소프트웨어에서 이름은 어디나 쓰인다. 의도를 분명히 밝혀라 코드가 하는 일을 짐작하기 어렵다. 코드의 단순성은 변하지 않았지만 좋은 이름을 통해 함수가 하는 일을 이해하기 쉬워졌다. 그릇된 정보를 피하라 의미 있게 구분하라 발음하기 쉬운 이름을 사용하라 검색하기 쉬운 이름을 사용하라 인코딩을 피하라 자신의 기억력을 자랑하지 마라 클래스 이…","fields":{"slug":"/clean-code-meaningful-name/"},"frontmatter":{"date":"February 09, 2022","title":"[Clean Code] 의미 있는 이름","tags":["Clean Code"]},"rawMarkdownBody":"\n## 의미 있는 이름\n\n> 소프트웨어에서 이름은 어디나 쓰인다.\n\n### 의도를 분명히 밝혀라\n\n```\n\n- 의도가 분명한 이름은 정말로 중요하다.\n\n- 좋은 이름을 지으려면 시간이 걸리지만 좋은 이름으로 절약하는 시간이 훨씬 더많다.\n\n- 이름을 주의깊게 살펴 더 나은 이름이 떠오르면 개선해라.\n\n- 존재 이유, 수행 기능, 사용 방법에 대한 주석이 따로 필요없게 이름을 지어라.\n\n```\n\n```typescript\nfunction getThem(): number[] {\n  const list1 = []\n  for (let x of theList) {\n    if (x[0] == 4) {\n      list1.push(x)\n    }\n  }\n  return list1\n}\n```\n\n코드가 하는 일을 짐작하기 어렵다.\n\n```typescript\nfunction getFlaggedCells(): Cell[] {\n  const flageedCells: Cell[] = []\n  for (let cell of gameBoard) {\n    if (cell.isFlagged()) {\n      flageedCells.push(cell)\n    }\n  }\n  return flageedCells\n}\n```\n\n코드의 단순성은 변하지 않았지만 좋은 이름을 통해 함수가 하는 일을 이해하기 쉬워졌다.\n\n### 그릇된 정보를 피하라\n\n```\n\n```\n\n### 의미 있게 구분하라\n\n### 발음하기 쉬운 이름을 사용하라\n\n### 검색하기 쉬운 이름을 사용하라\n\n### 인코딩을 피하라\n\n### 자신의 기억력을 자랑하지 마라\n\n### 클래스 이름\n\n### 메서드 이름\n\n### 기발한 이름은 피하라\n\n### 한 개념에 한 단어를 사용하라\n\n### 해법 영역에서 가져온 이름을 사용하라\n\n### 문제 영역에서 가져온 이름을 사용하라\n\n### 의미 있는 맥락을 추가하라\n\n### 불필요한 맥락을 없애라\n"},{"excerpt":"나중은 결코 오지 않는다. 깨끗한 코드란? 인간이 읽기 좋은 코드다. 단순하고 직접적이며 잘 쓴 문장처럼 읽혀야 한다. 다른 사람이 고치기 쉬워야한다. 세세한 사항까지 꼼꼼하게 처리하는 코드다. 주의 깊게 작성한 코드다. 결론 대부분 시간에 쫒겨 나쁜 코드를 작성하게 된다. 하지만 나쁜 코드는 나쁜 코드를 부른다. 그리고 나쁜 코드가 쌓일수록 생산성은 떨…","fields":{"slug":"/clean-code/"},"frontmatter":{"date":"February 09, 2022","title":"[Clean Code] 깨끗한 코드","tags":["Clean Code"]},"rawMarkdownBody":"\n> 나중은 결코 오지 않는다.\n\n## 깨끗한 코드란?\n\n- 인간이 읽기 좋은 코드다.\n- 단순하고 직접적이며 잘 쓴 문장처럼 읽혀야 한다.\n- 다른 사람이 고치기 쉬워야한다.\n- 세세한 사항까지 꼼꼼하게 처리하는 코드다.\n- 주의 깊게 작성한 코드다.\n\n## 결론\n\n대부분 시간에 쫒겨 나쁜 코드를 작성하게 된다. 하지만 나쁜 코드는 나쁜 코드를 부른다. 그리고 나쁜 코드가 쌓일수록 생산성은 떨어진다. 그러므로 급할수록 읽기 쉽게 코드를 작성하자.\n"},{"excerpt":"화살표 함수와 영역 책에서는 다음과 같은 코드를 제시하며 화살표 함수와 영역에 대해서 설명을 하고 있습니다. 위 코드는 \"gangwon\"이라는 객체의 print 프로퍼티에 메서드를 정의하고 이를 호출하는 과정에서 오류가 발생하였습니다.\n이는 setTimeout 메서드 내부에 정의된 함수의 this를 \"gangwon\"으로 생각하고 작성한 코드이기 때문에 발…","fields":{"slug":"/arrow-function-bind/"},"frontmatter":{"date":"January 25, 2022","title":"[JavaScript] 화살표 함수와 영역","tags":["JavaScript","this","arrow"]},"rawMarkdownBody":"\n`러닝 리액트(Learning React) 2판을 복습하면서 이해되지 않았던 부분에 대해서 정리 합니다.`\n\n---\n\n## 화살표 함수와 영역\n\n책에서는 다음과 같은 코드를 제시하며 **화살표 함수와 영역**에 대해서 설명을 하고 있습니다.\n\n```js\nconst gangwon = {\n  resorts: [\"용평\", \"평창\", \"강촌\", \"강릉\", \"홍천\"],\n  print: function (delay = 1000) {\n    setTimeout(function () {\n      console.log(this.resorts.join(\",\")) // this = Window\n    }, delay)\n  },\n}\n\ngangwon.print() // Cannot read property 'join' of undefined 라는 오류 발생\n```\n\n위 코드는 \"gangwon\"이라는 객체의 print 프로퍼티에 메서드를 정의하고 이를 호출하는 과정에서 오류가 발생하였습니다.\n이는 setTimeout 메서드 내부에 정의된 함수의 this를 \"gangwon\"으로 생각하고 작성한 코드이기 때문에 발생한 오류입니다. 실제 this의 값은 window 객체이며 window 객체 내부에는 \"resorts\"라는 배열이 존재하지 않기 때문에 \"join\"메서드 호출시 오류가 발생합니다.\n\n<br>\n\n```js\nconst gangwon = {\n  resorts: [\"용평\", \"평창\", \"강촌\", \"강릉\", \"홍천\"],\n  print: function (delay = 1000) {\n    setTimeout(() => { # 수정된 부분\n      console.log(this.resorts.join(\",\"))\n    }, delay)\n  },\n}\n\ngangwon.print() // 용평, 평창, 강촌, 강릉, 춘천\n```\n\n책에서는 이 문제를 해결하기 위해서 setTimeout 함수 안에 정의된 함수를 화살표 함수로 재정의하는 것을 해결방안으로 제시하고 있습니다. 이렇게 하면 this의 영역이 \"gangwon\"으로 설정이됩니다. 하지만 아래와 같이 코드를 바꾼다면 어떻게 될까요?\n\n<br>\n\n```js\nconst gangwon = {\n  resorts: [\"용평\", \"평창\", \"강촌\", \"강릉\", \"홍천\"],\n  print: (delay = 1000) => { # 수정된부분\n    setTimeout(() => {\n      console.log(this.resorts.join(\",\"))\n    }, delay)\n  },\n}\n\ngangwon.print() // Cannot read property 'join' of undefined 라는 오류 발생\n```\n\nprint 프로퍼티를 화살표 함수로 바꾸면 내부의 this가 gangwon에서 window로 다시 한번 변경 됩니다. 이러한 this의 변화 과정을 이해하기 위해서는 세가지의 배경지식이 있어야합니다.\n\n<br>\n\n- 첫번째, 함수를 어떤 객체의 메서드로 호출하면 this의 값은 그 객체를 사용한다.\n  <br>\n- 두번째, setTimeout 함수에서 this는 항상 전역 객체(window)를 this 바인딩한다.\n  <br>\n- 세번째, 일반 함수는 해당 객체를 바인딩하여 this의 값을 변경하고 화살표 함수는 상위 객체의 this를 이어받아서 사용한다.\n  <br>\n\n<br>\n\n![예제코드1](/this-example1.png)\n\n###### <center>예제 코드</center>\n\n<br>\n\n![예제결과1](/this-result1.png)\n\n###### <center>예제 코드 결과 </center>\n\n<br>\n\n위 코드에서 print 프로퍼티로 정의된 함수의 this는 첫번째 배경지식에 의해서 \"gangwon\" 객체를 바인딩하게 됩니다. 결과를 보시면 gangwon의 resorts가 콘솔 로그에 출력되어 있는 것을 확인할 수 있습니다. 그리고 그 아래에는 setTimeout 내부에서 두번째 배경지식에 의해서 this가 출력됩니다. 결과를 보시면 window 객체가 출력된 것을 확인할 수 있습니다. 이 두가지 배경지식과 마지막 세번째 배경지식을 이용하여 위의 코드를 재해석 해본다면 다음과 같습니다.\n\n<br>\n\n```js\nconst gangwon = {\n  resorts: [\"용평\", \"평창\", \"강촌\", \"강릉\", \"홍천\"],\n  print: (delay = 1000) => { #2\n    setTimeout(() => { #1\n      console.log(this.resorts.join(\",\"))\n    }, delay)\n  },\n}\n\ngangwon.print() // Cannot read property 'join' of undefined 라는 오류 발생\n```\n\n1. 화살표 함수로 인해서 setTimeout 내부의 this가 상위 객체의 this(gangwon)를 이어받아서 사용한다.\n2. print 프로퍼티의 메서드 정의도 화살표 함수이기 때문에 상위 객체의 this(Window)를 이어받아서 사용한다.\n3. 따라서 this = Window 이므로 Cannot read property 'join' of undefined 라는 오류 발생된다.\n"}]}},"pageContext":{}},"staticQueryHashes":[]}